# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LSgOFcb5ZWEgBuGJXkp4Jt-XBjzcReVE
"""

pip install streamlit pandas numpy scikit-learn matplotlib seaborn shap

"""# **Phase** **2**"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, GridSearchCV
import sklearn.metrics as metrics
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, confusion_matrix, classification_report
import shap
import streamlit as st

# Load Dataset
df = pd.read_csv("heart (1) (1).csv")

# Show first few rows
df.head()

df.describe()

"""# **Visualizing Data Distribution**"""

df.hist(bins=20, figsize=(15, 10), edgecolor='black')
plt.suptitle("Histograms of All Features", fontsize=16)
plt.show()

plt.figure(figsize=(15, 10))
for i, column in enumerate(df.columns[:-1], 1):  # Skip 'target' or last col if needed
    plt.subplot(4, 4, i)
    sns.boxplot(y=df[column])
    plt.title(f'Boxplot of {column}')
plt.tight_layout()
plt.show()

"""# **Relationship Between Variables**"""

plt.figure(figsize=(12, 10))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm', fmt='.2f')
plt.title("Correlation Matrix Heatmap")
plt.show()

plt.figure(figsize=(18, 5))

plt.subplot(1, 3, 1)
sns.scatterplot(x='age', y='chol', hue='target', data=df)
plt.title('Age vs. Cholesterol')

plt.subplot(1, 3, 2)
sns.scatterplot(x='age', y='thalach', hue='target', data=df)
plt.title('Age vs. Max Heart Rate')

plt.subplot(1, 3, 3)
sns.scatterplot(x='age', y='oldpeak', hue='target', data=df)
plt.title('Age vs. ST Depression')

plt.tight_layout()
plt.show()

"""# **Identify Data Quality Issues**"""

df.isnull().sum()

outliers_summary = {}
for column in df.select_dtypes(include=['float64', 'int64']).columns:
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = df[(df[column] < lower_bound) | (df[column] > upper_bound)]
    outliers_summary[column] = len(outliers)

outliers_summary

"""# **Phase 3**"""

# Display the first few rows to recall the data structure
print("\nOriginal DataFrame info:")
df.info()

"""Following the data understanding phase, the data preparation phase focuses on transforming the selected raw data into a clean, well-structured format suitable for the chosen modeling techniques. This involves several key steps outlined below, specifically applied to the 'heart.csv' dataset."""

#Display basic information about the dataset to re-verify columns
if not df.empty:
    print("Dataset Information:")
    df.info()
    print("\nDataset Columns:")
    print(df.columns)

    # Assuming 'target' is the name of the outcome variable.
    # If your target variable has a different name, please adjust it here.
    target_variable = 'target'

    if target_variable not in df.columns:
        print(f"\nError: Target variable '{target_variable}' not found in the dataset columns.")
        print("Please ensure the target variable name is correct.")
        # For demonstration, we'll list available columns if 'target' is missing
        # and you might need to manually set features and target.
        features = pd.DataFrame() # Empty
        target = pd.Series(dtype='float64') # Empty
    else:
        # All columns except the target variable are considered features.
        features = df.drop(columns=[target_variable])
        target = df[target_variable]
        print(f"\nSelected features (X) - first 5 rows:")
        print(features.head())
        print(f"\nSelected target variable (y) - first 5 rows:")
        print(target.head())
        print(f"\nAll {len(features.columns)} available features have been selected for initial analysis.")
else:
    print("DataFrame is empty. Cannot select data.")

"""All features present in this standard heart disease dataset (e.g., age, sex, cholesterol, blood pressure, etc.) are known to be clinically relevant or potentially correlated with heart conditions. Therefore, retaining all of them for the initial modeling stages is a common practice. Feature selection techniques can be applied later, after initial model evaluation, if dimensionality reduction is needed or if some features prove to be non-informative. The 'target' column directly indicates the presence or absence of heart disease, making it the clear dependent variable.

# **Data Cleaning**

Data cleaning involves addressing inconsistencies and errors identified in the Data Understanding phase. This typically includes handling missing values, correcting errors, and dealing with outliers. For this dataset, the process first checks for missing values. If any are found, a common strategy for numerical features is imputation (e.g., using the mean or median), and for categorical features, imputation with the mode or a constant. Outlier detection might have been performed visually (e.g., box plots) or statistically in the previous phase. For this example, it's assumed that significant outliers that distort the dataset might be capped or transformed, but often, tree-based models are robust to outliers, so aggressive removal isn't always necessary. Here, the focus will be on handling missing values.
"""

# Verify missing values again
print("\nMissing values in the dataset:")
print(df.isnull().sum())

numerical_cols_for_outliers = ['age', 'trestbps', 'chol', 'thalach', 'oldpeak']
plt.figure(figsize=(15, 10))
for i, col in enumerate(numerical_cols_for_outliers):
    plt.subplot(2, 3, i + 1)
    sns.boxplot(y=df[col])
    plt.title(f'Box plot of {col}')
plt.tight_layout()
plt.show()
# The plot will be generated by the python interpreter and shown in its output.
# In a Streamlit app, you would use st.pyplot(fig)